---
title: "R Notebook"
#output: html_notebook
author: "Val Syverson"
---

The scripts in this module produce compiled .csv files of sample ages and chronology controls in a format suitable for bulk upload into Neotoma.

The individual CSV files generated by the previous two modules are called from the directories "workflow/outputs/sampleages" and "workflow/outputs/chroncontrols", where those scripts will have saved them.

Load libraries:
```{r}
if ("here" %in% installed.packages()) {require(here)} else {install.packages("here"); require(here)}
i_am("final_scripts/5_compile_chronologies.Rmd")
source(here("final_scripts/functions/5_compile_chronologies_functions.R"))
```

Load computed new sample age ranges (analysis unit age limits) from generated files.
```{r}
# computed analysis unit ages
fpath <- here("outputs/sampleages")
names <- data.frame(collid = gsub(".csv","",dir(path = fpath)),
                    path = unname(sapply(dir(path = fpath),
                       function(x) paste(c(fpath,"/",x),collapse = ""))))
names <- subset(names,suppressWarnings(!is.na(as.numeric(names$collid))) & grepl("csv",names$path))
newchron.all <- list.stack(apply(names,1,function(x) {
  csv <- try(read.csv(file = x["path"]),silent = T)
  if (class(csv) == "data.frame") {
      return(suppressWarnings(cbind(collid = as.numeric(x["collid"]),csv)))}
  }),use.names = F)
colnames(newchron.all)[1] <- "collectionunitid"
```

Add inferred age ranges from spreadsheet. These were produced manually by Syverson according to the rules described in the manuscript (Syverson and Blois (2015)). If new collections have been added since the last update to the file "outputs/inferred_sampleages.csv", the user should similarly infer the age ranges for any undated analysis units therein and add them to their local copy of the spreadsheet before this step.
```{r}
inferred_sampleages <- read.csv(here("outputs/inferred_sampleages.csv"))[,1:6]
inferred_sampleages <- subset(inferred_sampleages,
                              inferred_sampleages$collectionunitid %in% newchron.all$collectionunitid)
inferred_sampleages$source <- "inferred"
newchron.all$source <- "computed"
newchron.all <- as.data.frame(rbind(newchron.all,inferred_sampleages))
```

Limit maximum ages at 2025 CE (-75)
```{r}
future <- which(newchron.all$sampleages.ageyounger < -75)
newchron.all[future,"sampleages.ageyounger"] <- -75
```


Load individual dates (chroncontrols):
```{r}
fpath2 <- here("outputs/chroncontrols")
names2 <- data.frame(collid = gsub(".csv","",dir(path = fpath2)),
                    path = unname(sapply(dir(path = fpath2),
                       function(x) paste(c(fpath2,"/",x),collapse = ""))))
names2 <- subset(names2,suppressWarnings(!is.na(as.numeric(names2$collid))))
newchron.ctrls <- list.stack(apply(names2,1,function(x) {
  csv <- try(read.csv(file = x["path"]),silent = T)
  if (class(csv) == "data.frame") {
      return(suppressWarnings(cbind(collid = as.numeric(x["collid"]),csv)))}
  }),use.names = F)
colnames(newchron.ctrls)[1] <- "collectionunitid"
```

Assign types to chronology controls:
```{r}
chroncontroltypes <- get_table("chroncontroltypes",limit = 999)[,1:3]
if (!exists("alldates")) alldates <- read.csv(here("data/alldates.csv"))
temp <- left_join(newchron.ctrls,alldates[,c("geochronid","geochrontypeid","agetypeid")])
table(temp$geochrontypeid)
typeindex <- data.frame(table(temp$geochrontypeid))

#Each type of chroncontrol needs a label and there is no way to do this automatically
typeindex$chroncontroltype <- c("Palaeomagnetic","Argon-argon",
                                "Radiocarbon, calibrated, Bayesian modelled",
                                "Optically stimulated luminescence",
                                "Thermoluminescence","Uranium-series")
#If there are fewer or more types than listed here, this will throw an error
#Adjust this list as necessary so that each type of chroncontrol has a matching value in the chroncontroltypes table in the following join.

typeindex <- left_join(typeindex[c("Var1","chroncontroltype")],chroncontroltypes)
temp <- left_join(temp,typeindex[,c("Var1","chroncontroltype","chroncontroltypeid")],
                  by = join_by(geochrontypeid == Var1))

temp[which(temp$geochrontypeid == "Carbon-14" & temp$agetypeid %in% c("calendar yr BP","cal yr BP")),"chroncontroltype"] <- "Calibrated radiocarbon years BP"
temp[which(temp$geochrontypeid == "Carbon-14" & temp$agetypeid %in% c("calendar yr BP","cal yr BP")),"chroncontroltypeid"] <- 17
newchron.ctrls <- temp[,c(colnames(newchron.ctrls),"chroncontroltypeid")]
```

Generate table of chronology ranges:
```{r}
newchron.range <- list.stack(tapply(newchron.all,newchron.all$collectionunitid,
                      dfbounds, simplify = F))
timeinfo <- cbind(filename = dir(here("outputs/sampleages")),
                  list.stack(sapply(dir(here("outputs/sampleages"),full.names = T), 
                                    file.info, simplify = F)))
timeinfo$collectionunitid <- unlist(sapply(timeinfo$filename,function(x) strsplit(x,".csv")))
timeinfo$dateprepared <- unlist(sapply(timeinfo$mtime,function(x) strsplit(as.character(x)," ")[[1]][1]))
newchron.range <- merge(newchron.range,timeinfo[,c("collectionunitid","dateprepared")])
newchron.range$chronologies.notes <- NA
```

Assign temporary chronology ids to the chronology ranges:
```{r}
#assign temporary chronids
newchron.range$TEMP_chronid <- paste0("TEMP",1:nrow(newchron.range))
```

Propagate the temporary chronology ids to the sample ages table:
```{r}
newchron.all <- left_join(newchron.all,                          
                        newchron.range[,c("collectionunitid","agemodel","TEMP_chronid")],
                          by = join_by(collectionunitid == collectionunitid,
                                       chronology.agemodel == agemodel), 
                          relationship = "many-to-one")
```

Propagate the temporary chronology ids to the chron controls table:
```{r}
temp <- distinct(inner_join(newchron.ctrls,alldates[,c("geochronid","analysisunitid")]))
temp[,c(1:2,4:8)] <- apply(temp[,c(1:2,4:8)],2,as.numeric)
newchron.all[,c(1:2,4:6)] <- apply(newchron.all[,c(1:2,4:6)],2,as.numeric)
newchron.sampleages <- split(newchron.all,newchron.all$chronology.agemodel)
templist <- list(bounds = distinct(left_join(temp,
                            distinct(newchron.sampleages$bounds[,c("analysisunitid","TEMP_chronid")]))), 
                 event = distinct(left_join(temp,
                            distinct(newchron.sampleages$event[,c("analysisunitid","TEMP_chronid")]))))
templist$bounds <- left_join(templist$bounds,subset(newchron.all,newchron.all$chronology.agemodel == "bounds")[,c("analysisunitid","TEMP_chronid")],relationship = "many-to-many")
templist$event <- left_join(templist$event,subset(newchron.all,newchron.all$chronology.agemodel == "event")[,c("analysisunitid","TEMP_chronid")],relationship = "many-to-many")
newchron.ctrls <- distinct(list.stack(templist))
```

Tag inferred chroncontrols with temporary chronology IDs and add to chroncontrol table:
```{r}
inferred_chroncontrols <- read.csv(here("outputs/inferred_chroncontrols.csv"))
inferred_chroncontrols <- distinct(subset(inferred_chroncontrols, inferred_chroncontrols$collectionunitid %in% newchron.range$collectionunitid))
temp <- distinct(left_join(inferred_chroncontrols[,1:9],newchron.all[,c("collectionunitid","chronology.agemodel","TEMP_chronid")],by = join_by(collectionunitid,chronology.agemodel), relationship = "many-to-many"))
newchron.ctrls <- distinct(rbind(newchron.ctrls,temp[,-9]))
```

Flag truncated age ranges using chronology number:
```{r}
future_chronids <- unique(newchron.all[future,"TEMP_chronid"])
newchron.range[which(newchron.range$TEMP_chronid %in% future_chronids),
   "chronologies.notes"] <- "younger age limits truncated at publication date (2025 CE)"
```

Save everything:
```{r}
write.csv(newchron.ctrls,here("outputs/new_caldates.csv"), row.names = F)
write.csv(newchron.range,here("outputs/new_chronologies.csv"), row.names = F)
write.csv(newchron.all,here("outputs/new_sampleages.csv"), row.names = F)
```


```{r}
rm(names, names2, temp, getbounds, timeinfo, future, future_chronids)
```

